{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Week 7: Geostatistics II: Bayesian Kriging\"\noutput: github_document\n---\n\n```{r global_options, eval=T, echo=F,results='hide'}\nknitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='Figs/',  warning=FALSE, message=FALSE)\nrm(list=ls())\nlibrary(sp)\nlibrary(gstat)\nlibrary(RColorBrewer)\nlibrary(geoR)\n```\n\n# More Notes on Assumption of Kriging\n\n## Stationarity\n\nConsider a spatial process $Z(s)$ with a mean $m(s)$ and variance $\\sigma^2(s)$\nexists $\\forall s\\in\\mathcal{D}$. \n\n1. The process is `strictly stationary` or `strongly stationary` if, for\n   any given $n\\ge 1$, any set set of $n$ sites and any $h\\in\n   \\mathcal{R}^d$, the distribution of $Z(s_i), \\ldots, Z(s_n)$ is the same\n   as $Z(s_i+h), \\ldots, Z(s_n+h)$\n\n2. A less restrictive assumption is `weak stationarity` or `second-order\n   stationarity`, which is to assume $m(s)\\equiv \\mu$ and $cov[Z(s_i),\n   Z(s_i+h)]=C(h)$ for any $h\\in \\mathcal{R}^{d}$ s.t. both $s_i$ and\n   $s_i+h$ are within $\\mathcal{D}$. $C(h)$ is `covariogram`.\n\n\t+ $cov[Z(s_i), Z(s_i+h)]= E{[Z(s_i)-\\mu][Z(s_i+h)-\\mu]}=E[Z(s_i)Z(s_i+h)]-\\mu^2=C(h)$ \n\t+ $\\sigma^2(Z(s_i))=E[Z(s_i)-\\mu]^2=E[Z(s_i)^2]-\\mu^2=C(0)$\n\t+ $\\rho(h)=\\frac{C(h)}{\\sigma(Z(s_i))\\sigma(Z(s_i+h))}$ is\n\t  `correlogram`\n\n3. The `second-order stationarity` assumes the existence of covariance.\n   For cases where covariance and variance do not exist, we assume the\n   stationarity of the difference. \n  \n\t+ $E[Z(s)]=\\mu, \\forall s$\n\t+ $\\sigma^2[Z(s_i+h)-Z(s_i)]=E[Z(s_i+h)-Z(s_i)]^2=2\\gamma(h)$\n\t+ $\\hat{\\gamma(h)}= \\frac{1}{2N(h)}\\sum_{(s_i, s_j)\\in N(h)}^{N(h)}[Z(s_i)-Z(s_j)]^2$\n\t+ $2\\gamma(h)$ is called `variogram` and $2\\gamma(h)$ is therefore\n\t  `semivariogram`\n\t+ `intrinsic stationarity`\n\n\n## Variogram \n\nNot every function could be used as a variogram. Suppose there are stationary random\nvariables $Z(s_1), Z(s_2), \\dots, Z(s_n)$ with expectation $\\mu$ and\ncovariance $C(h)$. Let $Y$ be the linear combination of these variables.\n$Y=\\sum_{i=1}^{n}\\omega_iZ(s_i)$, which is also a random variable itself\nand must have nonnegative variance. \n\n$$\\sigma^2(Y)=\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\omega_i\\omega_jC(s_i-s_j)\\ge 0$$\n\nTherefore legal covariance functions much ensure that the variance of $Y$\nis always non-negative. This type of functions is often referred to as\n`non-negative definite`. If $\\sigma(Y) \\ge 0$, it is called `positive\ndefinite`.\n\nSince for variogram $\\gamma(h) = C(0)-C(h)$. The variance of $Y$,\n$\\sigma^2(Y)$, can be rewritten using $\\gamma(h)$:\n\n$$\\sigma^2(Y) = C(0)\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\omega_i\\omega_j - \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\omega_i\\omega_j\\gamma(s_i-s_j)\\ge0$$\n\nIn case of $\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\omega_i\\omega_j =0$:\n\n$$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\omega_i\\omega_j\\gamma(s_i-s_j)\\le0$$ \n\nTherefore, legal variogram function must be `negative definite`.\n\nThe common examples of the legal variogram or covariogram functions include\n`Spherical`, `Exponential`, `Gaussian`, `Matern` that we have used for the\nlast week.\n\n\n## Kriging\n\nSpatial prediction are commonly represented as:\n\n$$Y(s) = m(s) + Z(s) + \\epsilon$$,\n\nwhere $Y(s)$ represent the primary variable of study at location $s$,\n$m(s)=\\beta X(s)$ is the mean or trend component (or trend) that could be\nmodeled through covariate $X(s)$, $Z(s)$ is the spatial effect that are\noften assumed as Gaussian distributed specified by covariance functions\n$C(h; \\phi, \\sigma^2)$, $\\epsilon$ is the random noises (nugget effect)\nspecified by parameter $\\tau^2$\n\n\nDifferent specifications of the trend component $m(s)$ leads to different\ntypes of kriging methods. \n\n+ Simple kriging: $m(s)\\equiv\\mu$\n+ Ordinary kriging: $m(s)$ is constant but unknown\n+ Regression kriging: $m(s)$ is modeled through covariates $X(s)$\n     - Universal kriging\n     - Kriging with external drift\n\nUnder the assumption of Gaussian distributed variables, kriging leads to\nthe unbiased linear estimation with minimum variance or best linear\nunbiased estimation (BLUE). \n\nIf the measurements cannot satisfy the Gaussian assumption, transformation\nusually needs to be performed first (e.g., log transform) or Bayesian\nhierarchical model can be used. \n\n\n# Model-based Geostatistics\n\n```{r cloud1, echo=T, eval=T, results='hide'}\ndata(meuse)\nmeuse=cbind(meuse, log(meuse$lead))\n# convert it to a geodata object that geoR requires. \nmeuse=as.geodata(meuse,coords.col=1:2, data.col=15, covar.col=8)\n# generate variogram cloud. geoR provides two different ways for the sample\n# variogram values, classical and modules. The classical one is the one we\n# talked about in the class, and the modules one is the \ncloud1 <- variog(meuse, option = \"cloud\", estimation.type='classical')\nnames(cloud1)\nhead(cloud1$u, n=20)\nhead(cloud1$v, n=20)\nplot(cloud1)\n```\n\n```{r cloud2, echo=T, eval=T, results='hide'}\n#box-plot of the cloud\nbin1 <- variog(meuse, breaks=seq(45, 2000, by = 100), estimation.type='classical',bin.cloud=T, max.distance=2000) \nplot(bin1, bin.cloud=T)\n\n#variogram fitting\n\n##by eye\nvariogram <- variog(meuse, breaks=seq(45, 4000, by = 100))\nplot(variogram)\nlines.variomodel(cov.model=\"sph\", cov.pars=c(0.4,1000), nug=0.1, max.dist=4000, lty=2, col='red')\n\n#Fit the spherical variogram using the default option (check ?variofit manual).\nfit1 <- variofit(variogram, cov.model=\"sph\", ini.cov.pars=c(0.4,1000), fix.nugget=FALSE, nugget=0.1)\n\nlines(fit1, lty=1)\n\n#Use Cressies weights:\nfit2 <- variofit(variogram, cov.model=\"sph\", weights=\"cressie\", ini.cov.pars=c(0.4,1000), fix.nugget=FALSE, nugget=0.1) \n\nlines(fit2, lty=1, col=\"green\")\n\n#Use equal weights (simply OLS):\nfit3 <- variofit(variogram, cov.model=\"sph\", ini.cov.pars=c(0.4,1000), weights=\"equal\", fix.nugget=FALSE, nugget=0.1)\n\nlines(fit3, lty=1, col=\"orange\")\n\n#MML:\nml <- likfit(meuse, cov.model=\"sph\", ini.cov.pars=c(0.4,1000), fix.nugget=FALSE, nugget=0.1) \n\nlines(ml, col=\"blue\")\n\n#REML:\nrml <- likfit(meuse, cov.model=\"sph\", ini.cov.pars=c(0.4,1000), fix.nugget=FALSE, nugget=0.1, lik.method = \"RML\" )\n\nlines(rml, col=\"purple\")\n\n\n# \nenv.mc <- variog.mc.env(meuse, obj.var=variogram)\nenv.model <- variog.model.env(meuse, obj.var=variogram, model=fit2)\npar(mfrow=c(1,2))\nplot(variogram, envelope=env.mc)\nplot(variogram, envelope=env.model)\n\n# profile likelihood\n#prof <- proflik(ml, geodata = meuse, sill.val = seq(0.20, 1, l = 5), range.val = seq(800, 1200, l = 6), uni.only = FALSE )\n#plot(prof)\n```\n\n# Simple Kriging and Ordinary Kriging\n\n```{r kriging, echo=T, eval=T, results='hide'}\ndata(meuse.grid)\npredSites=cbind(meuse.grid$x, meuse.grid$y)\nOKpred=krige.conv(meuse, locations=predSites, krige=krige.control(type.krige='ok', obj.m=ml))\n\nOKresult=as.data.frame(cbind(OKpred$predict, OKpred$krige.var))\ncoordinates(OKresult)=predSites\ngridded(OKresult)=TRUE\nplot(OKresult)\n\n# the constant mean is specified by beta\nmean(meuse$data)\nSKpred=krige.conv(meuse, locations=predSites, krige=krige.control(type.krige='sk', obj.m=ml, beta=6)) \nSKresult=as.data.frame(cbind(SKpred$predict, SKpred$krige.var))\ncoordinates(SKresult)=predSites\ngridded(SKresult)=TRUE\n\np1=spplot ( OKresult, \"V1\")\np2=spplot(OKresult,\"V2\")\np3=spplot(SKresult,\"V1\")\np4=spplot(SKresult,\"V2\")\n\nprint(p1, position = c(0,.5,.5,1),more=T)\nprint(p2, position = c(.5,.5,1,1),more = T)\nprint(p3, position = c(0,0,.5,0.5),more=T)\nprint(p4, position = c(.5,0,1,0.5))\n```\n\n# Regression Kriging\n\n```{r regressionkriging, echo=T, eval=T, results='hide'}\nRKpred=krige.conv(meuse, locations=predSites, krige=krige.control(type.krige='ok', obj.m=ml, trend.d=~dist, trend.l= ~meuse.grid$dist)) \nRKresult=as.data.frame(cbind(RKpred$predict, RKpred$krige.var))\ncoordinates(RKresult)=predSites\ngridded(RKresult)=TRUE\n\np5=spplot ( RKresult, \"V1\")\np6=spplot(RKresult,\"V2\")\n\nprint(p5, position = c(0,.5,.5,1),more=T)\nprint(p6, position = c(.5,.5,1,1))\n```\n\n# Bayesian Kriging\n\n```{r Bayeskriging, echo=T, eval=F, results='hide'}\n\n#Warining: the following codes are very computationally demanding. In the\n#interest of time,  I made the specification of the model unrealistically\n# simple.\n\nxrange=range(meuse$coords[,1])\nyrange=range(meuse$coords[,2])\nx=seq(xrange[1], xrange[2], length=10)\ny=seq(yrange[1], yrange[2], length=10)\npredSites=expand.grid(x,y)\n\n#model.spec <- model.control(trend.d=~dist, trend.l=~meuse.grid$dist, cov.model=\"matern\", kappa=0.5, lambda=1) \n\nmodel.spec <- model.control(cov.model=\"matern\", kappa=0.5, lambda=1) \n\nprior.spec <- prior.control(beta.prior=\"flat\",sigmasq.prior=\"reciprocal\",tausq.rel.prior=\"uniform\",tausq.rel.discrete=seq(from=0.0,to=1.0,by=0.1))\n\noutput.spec <- output.control(quantile=c(0.50,0.025,0.975), n.post=100, n.pred=100)\n\nbayes1 <- krige.bayes(meuse, locations=predSites, borders=NULL, model=model.spec, prior=prior.spec, output=output.spec)\n\nout <- bayes1$posterior\nout <- out$sample\nbeta0.qnt <- quantile(out$beta0, c(0.50,0.025,0.975))\nbeta1.qnt <- quantile(out$beta1, c(0.50,0.025,0.975))\nphi.qnt <- quantile(out$phi, c(0.50,0.025,0.975))\nsigmasq.qnt <- quantile(out$sigmasq, c(0.50,0.025,0.975))\ntausq.rel.qnt <- quantile(out$tausq.rel, c(0.50,0.025,0.975))\ntausq <- (out$tausq.rel)*(out$sigmasq) \ntausq.qnt <- quantile(tausq, c(0.50,0.025,0.975))\n\nsamples.lead<- cbind(out$beta0,out$beta1,out$phi,out$sigmasq,tausq)\nsummary.lead <- rbind(beta0.qnt,beta1.qnt,phi.qnt,sigmasq.qnt,tausq.qnt)\n\nout2 <- bayes1$predictive\npredictive.mean <- out2$mean.simulations\npredictive.variance <- out2$variance.simulations\npredictive.sd <- sqrt(predictive.variance)\npredictive.quantiles <- out2$quantiles.simulations\n\n\nsummary.predictive <- cbind(predictive.mean,predictive.sd,predictive.quantiles) \n\n\ntest=as.data.frame(summary.predictive)\ncoordinates(test)=predSites\ngridded(test)=TRUE\n\nspbayes1=spplot(test, 'predictive.mean')\nspbayes2=spplot(test, 'predictive.sd')\n\n\nprint(spbayes1, position = c(0,.5,.5,1),more=T)\nprint(spbayes2, position = c(.5,.5,1,1))\n\n```\n\n",
    "created" : 1507670411810.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1442103639",
    "id" : "33A61126",
    "lastKnownWriteTime" : 1507738309,
    "last_content_update" : 1507738309898,
    "path" : "~/Git/hub/geog5330-fall2017/week7/kriging2-model-based.Rmd",
    "project_path" : "kriging2-model-based.Rmd",
    "properties" : {
        "marks" : "<:277,-1\n>:277,0"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}