{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Week 4: Geostatistics I\"\noutput: github_document\n---\n\n```{r global_options, echo=FALSE, eval =T, results='asis'}\nknitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='Figs/', warning=FALSE, message=FALSE) \nrm(list=ls()) \nlibrary(sp) \nlibrary(gstat) \nlibrary(RColorBrewer) \nlibrary(plotGoogleMaps)\n```\n\n# Data\n\nThe `meuse` data set contains the measurements of the concentration of\nheavy metals around the banks of the Maas river in the area west of the\ntown Stein in the Netherlands. These heavy metals were accumulated over the\nyears because of river pollution. The data sets has many variables but here\nwe will use the coordinates and the concentration of zinc at each data\npoint. You can see the maps of the study area. \n\n```{r meuse, echo=T, eval=T}\ndata(meuse)\ncoordinates(meuse)=~x+y\nproj4string(meuse) = CRS('+init=epsg:28992')\n\nplotGoogleMaps(meuse, filename = 'meuse.html')\n```\n\nWe first explored the data a little more to get more comfortable with the\ndatasets. \n\n```{r meuse2, echo=T, eval=T}\n\n#check the name of each field\nnames(meuse)\n\nhist(meuse$zinc,breaks=20)\n#shapiro.test(meuse$zinc)\n\n#hist(log(meuse$zinc),breaks=20)\n#shapiro.test(log(meuse$zinc))\n\nbubble(meuse, 'zinc', col=brewer.pal(2, 'Reds'), main= 'zinc concentrations (ppm)')\n\nplot(log(zinc)~sqrt(dist), meuse)\nabline(lm(log(zinc)~sqrt(dist), meuse))\n```\nWe can first use IDW (inverse distance weighted) method to interpolate the\nscattering measurements into a continuous surface. \n\n```{r idw, echo=T, eval=T}\ndata(\"meuse.grid\")\nclass(meuse.grid)\ncoordinates(meuse.grid)=~x+y\ngridded(meuse.grid)=TRUE\n\nproj4string(meuse.grid)=proj4string(meuse)\nzinc.idw = idw(zinc~1, meuse, meuse.grid)\n#image(meuse.grid['dist'], col=rev(brewer.pal(9, 'Reds')))\n\nstr(zinc.idw)\nspplot(zinc.idw[,1], main='zinc, inverse distance weighted estimation')\n```\n\n# Kriging\n\nIn addition to the point measurements of in `meuse`, we have another set of\nauxiliary dataset `meuse.grid`, containing a set of gridded auxiliary\ninformation about this area of study. We will use the distance to the\nriver. \n\n```{r meusegrid, echo=T, eval=T}\ndata(meuse.grid)\nnames(meuse)\n\ncoordinates(meuse.grid)=~x+y\ngridded(meuse.grid)=TRUE \nproj4string(meuse.grid)=proj4string(meuse)\nplot(meuse.grid['dist'], col=rev(brewer.pal(9, 'Reds')), main='distance to river (m)')\n\n```\n\n##Variogram\n\n```{r variogram, echo=T, eval=T}\nlzn.vgm = variogram(log(meuse$zinc)~1, meuse)\nlzn.vgm\nplot(lzn.vgm)\n\n\nlzn.vgm.map = variogram(log(zinc)~1, meuse, map=TRUE, cutoff=1500, width=100)\nplot(lzn.vgm.map)\n\n\nlzn.fit = fit.variogram(lzn.vgm, model = vgm(1, \"Exp\", 900, 1))\nlzn.fit\nplot(lzn.vgm, lzn.fit)\n\n\n# accounting for other covariates/auxiliary information\n# residual variogram of the linear regression\nlznr.vgm = variogram(log(zinc)~sqrt(dist), meuse)\nlznr.fit = fit.variogram(lznr.vgm, model = vgm(1, \"Exp\", 300, 1))\nlznr.fit\nplot(lznr.vgm, lznr.fit)\n```\n\n### Directional variogram\n\n```{r variogram2, echo=T, eval=T}\nlzn.dir = variogram(log(zinc)~1, meuse, alpha = c(0, 45, 90, 135))\nlzndir.fit = vgm(.59, \"Sph\", 1200, .05, anis = c(45, .4))\nplot(lzn.dir, lzndir.fit, as.table = TRUE)\n\nlznr.dir = variogram(log(zinc)~sqrt(dist), meuse, alpha = c(0, 45, 90, 135))\nplot(lznr.dir, lznr.fit, as.table = TRUE)\n```\n\n\n## Kriging prediction\n\n```{r kriging, echo=T, eval=T}\nlzn.kriged = krige(log(zinc)~1, meuse, meuse.grid, model = lzn.fit)\nnames(lzn.kriged)\nplot(lzn.kriged[,1], main='zinc, simple kriging estimation')\n\n#kriging also output the variance of the estimation\nplot(lzn.kriged[,2], main='zinc, variance of simple kriging estimation')\n\n# accounting for other covariates/auxiliary information\n\nlznr.kriged = krige(log(zinc)~sqrt(dist), meuse, meuse.grid, model = lzn.fit)\n\nplot(lznr.kriged[,1], main='zinc, universal kriging estimation')\n\n#kriging also output the variance of the estimation\nplot(lznr.kriged[,2], main='zinc, variance of universal kriging estimation')\n```\n\n\n### Cross-validation \n\n```{r kriging, echo=T, eval=T}\nchoose100 <- sample(1:155, 100) \ntraining <- meuse[choose100, ] \nvalidation <- meuse[-choose100, ] \n\n#Now, we can use the part model to estimate the variogram.\nlzn.vgm.training = variogram(log(zinc)~1, training)\nlzn.fit.training = fit.variogram(lzn.vgm.training, model = vgm(1, \"Sph\", 900, 1))\nplot(lzn.vgm.training,lzn.fit.training)\nlzn.kriged.training = krige(log(zinc)~1, training, validation, model = lzn.fit.training)\ndifference <- log(validation$zinc) - lzn.kriged.training$var1.pred \nsummary(difference)\nrmse <- sqrt(sum(difference^2))\nrmse\n\nplot(log(validation$zinc), lzn.kriged.training$var1.pred, xlab= 'observed values', ylab='predicted values')\nabline(lm(log(validation$zinc)~lzn.kriged.training$var1.pred))\n\n# or use qqplot\nqqplot(log(validation$zinc), lzn.kriged.training$var1.pred)\n\n\n#A more automated way is to use the function krige.cv: \ncv<-krige.cv(log(zinc)~1,meuse, model=lzn.fit,nfold=nrow(meuse)) \nnames(cv)\nrmse2 <- sqrt(sum(cv$residual^2))\nrmse2\n```\n\n##Simulation: Explore the space of uncertainty\n\n### Unconditional simulation\n\nGenerate a set of unconditional simulation based on the specified variogram\n\n```{r simulation1, echo=T, eval=T}\n# Generate a set of unconditional simulation based on the specified variogram\nxy <- expand.grid(1:100, 1:100)\nnames(xy) <- c('x','y')\ng.dummy <- gstat(formula=z~1, locations=~x+y, dummy=T, beta=1, model=vgm(psill=0.025, range=10, model='Gau', nugget=0.0001), nmax=21) \nyy <- predict(g.dummy, newdata=xy, nsim=4)\ncoordinates(yy)=~x+y\ngridded(yy) =TRUE\nspplot(yy)\n```\n\n### Conditional simulation\n\nGenerate a set of simulation based on the specified variogram and\nconditional to a set of observations\n\n```{r simulation2, echo=T, eval=T}\nlzn.condsim = krige(log(zinc)~1, meuse, newdata=meuse.grid, model = lzn.fit, nmax = 30, nsim = 4)\nspplot(lzn.condsim, main='four realizations of conditional simulation')\n\n#accounting for covariates\nlzn.condsim2 = krige(log(zinc)~sqrt(dist), meuse, newdata=meuse.grid, model = lznr.fit, nmax = 30, nsim = 4)\nspplot(lzn.condsim2, main='four realizations of conditional simulation')\n```\n\n",
    "created" : 1507066834277.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3904661301",
    "id" : "39048A08",
    "lastKnownWriteTime" : 1507068330,
    "last_content_update" : 1507068330759,
    "path" : "~/Git/hub/geog5330-fall2017/week6/kriging.Rmd",
    "project_path" : "kriging.Rmd",
    "properties" : {
        "marks" : "<:186,19\n>:186,20"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}